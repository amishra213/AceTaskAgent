"""
Backward Compatibility Wrappers for Interface Standardization

This module provides wrapper functions to convert between legacy dict formats
and new TypedDict schemas. Use these during the migration period (Week 1-4).

After full migration (Week 9-10), this module can be deprecated.
"""

from typing import Dict, Any, Optional, List
from datetime import datetime
import uuid
import os

from task_manager.models.messages import (
    AgentExecutionResponse,
    ArtifactMetadata,
    ErrorResponse,
    SystemEvent,
    TempDataSchema,
    CacheEntrySchema,
    create_error_response
)
from task_manager.utils.logger import get_logger

logger = get_logger(__name__)


# ============================================================================
# AGENT RESPONSE WRAPPERS
# ============================================================================

def legacy_response_to_standard(
    legacy_response: Dict[str, Any],
    agent_name: str,
    operation: str,
    execution_time_ms: Optional[int] = None
) -> AgentExecutionResponse:
    """
    Convert legacy agent response dict to standardized AgentExecutionResponse.
    
    Handles various legacy formats:
    - {"success": bool, "result": dict, "file": str}
    - {"success": bool, "result": dict, "error": str}
    - {"success": bool, "data": dict}
    
    Args:
        legacy_response: Old-style dict response
        agent_name: Name of the agent
        operation: Operation that was performed
        execution_time_ms: Optional execution time
    
    Returns:
        Standardized AgentExecutionResponse
    """
    success = legacy_response.get("success", False)
    
    # Extract result data
    result = legacy_response.get("result", {})
    if not result and "data" in legacy_response:
        result = legacy_response.get("data", {})
    
    # Extract artifacts from various legacy fields
    artifacts = []
    if "file" in legacy_response and legacy_response["file"]:
        file_path = legacy_response["file"]
        artifacts.append(ArtifactMetadata(
            type=_guess_file_type(file_path),
            path=str(file_path),
            size_bytes=_get_file_size(file_path),
            description=f"Generated by {agent_name}",
            mime_type=_guess_mime_type(file_path)
        ))
    
    if "output_path" in legacy_response and legacy_response["output_path"]:
        file_path = legacy_response["output_path"]
        artifacts.append(ArtifactMetadata(
            type=_guess_file_type(file_path),
            path=str(file_path),
            size_bytes=_get_file_size(file_path),
            description=f"Output from {agent_name}",
            mime_type=_guess_mime_type(file_path)
        ))
    
    # Extract error if present
    error_msg = legacy_response.get("error")
    
    # Determine status
    if success:
        status = "success"
    else:
        status = "failure"
    
    # Create standardized response
    return AgentExecutionResponse(
        status=status,
        success=success,
        result=result,
        artifacts=artifacts,
        execution_time_ms=execution_time_ms or 0,
        timestamp=datetime.now().isoformat(),
        agent_name=agent_name,
        operation=operation,
        blackboard_entries=[],
        error=error_msg,
        warnings=[],
        confidence_score=legacy_response.get("confidence", None),
        completeness_score=legacy_response.get("completeness", None)
    )


def standard_response_to_legacy(
    standard_response: AgentExecutionResponse
) -> Dict[str, Any]:
    """
    Convert standardized AgentExecutionResponse back to legacy dict format.
    
    Used for backward compatibility where external code expects old format.
    
    Args:
        standard_response: Standardized response
    
    Returns:
        Legacy dict format
    """
    legacy = {
        "success": standard_response["success"],
        "result": standard_response["result"]
    }
    
    # Add file path if artifacts present
    if standard_response.get("artifacts") and len(standard_response["artifacts"]) > 0:
        legacy["file"] = standard_response["artifacts"][0]["path"]
    
    # Add error if present
    error = standard_response.get("error")
    if error:
        legacy["error"] = error
    
    return legacy


# ============================================================================
# TEMP STORAGE WRAPPERS
# ============================================================================

def legacy_temp_data_to_standard(
    legacy_data: Dict[str, Any],
    key: str,
    category: str,
    session_id: str,
    task_id: Optional[str] = None,
    source_agent: Optional[str] = None
) -> TempDataSchema:
    """
    Convert legacy temp data dict to standardized TempDataSchema.
    
    Args:
        legacy_data: Old-style data dict
        key: Data key
        category: Data category
        session_id: Session ID
        task_id: Optional task ID
        source_agent: Optional source agent name
    
    Returns:
        Standardized TempDataSchema
    """
    now = datetime.now().isoformat()
    
    return TempDataSchema(
        schema_version="1.0",
        data_type=category,
        created_at=now,
        updated_at=now,
        key=key,
        task_id=task_id,
        session_id=session_id,
        data=legacy_data,
        ttl_hours=24,
        expires_at=None,
        source_agent=source_agent,
        source_operation=None
    )


def standard_temp_data_to_legacy(
    standard_data: TempDataSchema
) -> Dict[str, Any]:
    """
    Extract data payload from TempDataSchema for legacy code.
    
    Args:
        standard_data: Standardized temp data
    
    Returns:
        Legacy data dict
    """
    return standard_data["data"]


# ============================================================================
# CACHE WRAPPERS
# ============================================================================

def legacy_cache_to_standard(
    input_data: Dict[str, Any],
    output_data: Dict[str, Any],
    namespace: str,
    key: str,
    agent_name: str,
    operation: str,
    execution_time_ms: int,
    ttl_seconds: int = 86400
) -> CacheEntrySchema:
    """
    Convert legacy cache data to standardized CacheEntrySchema.
    
    Args:
        input_data: Input that produced the output
        output_data: Cached output
        namespace: Cache namespace
        key: Cache key
        agent_name: Agent that produced the result
        operation: Operation that was performed
        execution_time_ms: Execution time
        ttl_seconds: Time to live
    
    Returns:
        Standardized CacheEntrySchema
    """
    import hashlib
    import json
    
    # Create input hash
    input_str = json.dumps(input_data, sort_keys=True)
    input_hash = hashlib.sha256(input_str.encode()).hexdigest()
    
    return CacheEntrySchema(
        namespace=namespace,
        key=key,
        cached_at=datetime.now().isoformat(),
        ttl_seconds=ttl_seconds,
        hit_count=0,
        input_hash=input_hash,
        output_data=output_data,
        agent_name=agent_name,
        operation=operation,
        execution_time_ms=execution_time_ms
    )


# ============================================================================
# ERROR WRAPPERS
# ============================================================================

def exception_to_error_response(
    exception: Exception,
    source: str,
    error_code: Optional[str] = None,
    task_id: Optional[str] = None,
    operation: Optional[str] = None,
    recoverable: bool = True
) -> ErrorResponse:
    """
    Convert Python exception to standardized ErrorResponse.
    
    Args:
        exception: The exception that occurred
        source: Where the error occurred
        error_code: Optional error code
        task_id: Optional task ID
        operation: Optional operation name
        recoverable: Whether error is recoverable
    
    Returns:
        Standardized ErrorResponse
    """
    import traceback
    
    # Determine error type
    error_type = "execution_error"
    if isinstance(exception, TimeoutError):
        error_type = "timeout_error"
    elif isinstance(exception, ValueError):
        error_type = "validation_error"
    elif isinstance(exception, (IOError, OSError)):
        error_type = "resource_error"
    elif isinstance(exception, ImportError):
        error_type = "dependency_error"
    
    # Determine severity
    severity = "medium"
    if isinstance(exception, (TimeoutError, ConnectionError)):
        severity = "high"
    elif isinstance(exception, ValueError):
        severity = "low"
    
    # Generate error code if not provided
    if not error_code:
        error_code = f"{source.upper()}_{error_type.upper()}_001"
    
    return create_error_response(
        error_code=error_code,
        error_type=error_type,
        message=str(exception),
        source=source,
        severity=severity,
        details={
            "exception_type": type(exception).__name__,
            "exception_args": str(exception.args)
        },
        task_id=task_id,
        operation=operation,
        stack_trace=traceback.format_exc(),
        recoverable=recoverable,
        recovery_suggestions=_get_recovery_suggestions(exception),
        retry_after_seconds=60 if recoverable else None
    )


def _get_recovery_suggestions(exception: Exception) -> List[str]:
    """Generate recovery suggestions based on exception type."""
    suggestions = []
    
    if isinstance(exception, TimeoutError):
        suggestions.append("Retry with longer timeout")
        suggestions.append("Check network connectivity")
    elif isinstance(exception, ConnectionError):
        suggestions.append("Check service availability")
        suggestions.append("Verify network configuration")
    elif isinstance(exception, FileNotFoundError):
        suggestions.append("Verify file path is correct")
        suggestions.append("Check file permissions")
    elif isinstance(exception, ValueError):
        suggestions.append("Validate input data")
        suggestions.append("Check data format")
    elif isinstance(exception, ImportError):
        suggestions.append("Install missing dependencies")
        suggestions.append("Check Python environment")
    else:
        suggestions.append("Check logs for more details")
        suggestions.append("Contact support if issue persists")
    
    return suggestions


# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def _guess_file_type(file_path: str) -> str:
    """Guess file type from extension."""
    ext = os.path.splitext(file_path)[1].lower()
    type_map = {
        ".csv": "csv",
        ".json": "json",
        ".xlsx": "excel",
        ".xls": "excel",
        ".pdf": "pdf",
        ".png": "image",
        ".jpg": "image",
        ".jpeg": "image",
        ".txt": "text",
        ".md": "markdown"
    }
    return type_map.get(ext, "unknown")


def _guess_mime_type(file_path: str) -> str:
    """Guess MIME type from extension."""
    ext = os.path.splitext(file_path)[1].lower()
    mime_map = {
        ".csv": "text/csv",
        ".json": "application/json",
        ".xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        ".pdf": "application/pdf",
        ".png": "image/png",
        ".jpg": "image/jpeg",
        ".jpeg": "image/jpeg",
        ".txt": "text/plain",
        ".md": "text/markdown"
    }
    return mime_map.get(ext, "application/octet-stream")


def _get_file_size(file_path: str) -> int:
    """Get file size in bytes, return 0 if file doesn't exist."""
    try:
        return os.path.getsize(file_path)
    except (OSError, FileNotFoundError):
        return 0


# ============================================================================
# VALIDATION HELPERS
# ============================================================================

def is_standard_response(response: Any) -> bool:
    """
    Check if response is in standardized format.
    
    Args:
        response: Response to check
    
    Returns:
        True if response is AgentExecutionResponse format
    """
    if not isinstance(response, dict):
        return False
    
    required_fields = {
        "status", "success", "result", "artifacts",
        "execution_time_ms", "timestamp", "agent_name", "operation"
    }
    
    return required_fields.issubset(response.keys())


def is_legacy_response(response: Any) -> bool:
    """
    Check if response is in legacy format.
    
    Args:
        response: Response to check
    
    Returns:
        True if response is legacy dict format
    """
    if not isinstance(response, dict):
        return False
    
    # Legacy responses have "success" but not full standard fields
    return "success" in response and not is_standard_response(response)


def auto_convert_response(
    response: Dict[str, Any],
    agent_name: str,
    operation: str,
    execution_time_ms: Optional[int] = None
) -> AgentExecutionResponse:
    """
    Automatically convert response to standard format if needed.
    
    Args:
        response: Response in any format
        agent_name: Agent name
        operation: Operation name
        execution_time_ms: Optional execution time
    
    Returns:
        Standardized AgentExecutionResponse
    """
    if is_standard_response(response):
        logger.debug(f"Response from {agent_name} already in standard format")
        return response  # type: ignore
    
    if is_legacy_response(response):
        logger.debug(f"Converting legacy response from {agent_name} to standard format")
        return legacy_response_to_standard(
            response, agent_name, operation, execution_time_ms
        )
    
    # Unknown format, create minimal standard response
    logger.warning(f"Unknown response format from {agent_name}, creating minimal standard response")
    return AgentExecutionResponse(
        status="success",
        success=True,
        result=response,
        artifacts=[],
        execution_time_ms=execution_time_ms or 0,
        timestamp=datetime.now().isoformat(),
        agent_name=agent_name,
        operation=operation,
        blackboard_entries=[],
        error=None,
        warnings=["Response format was non-standard"],
        confidence_score=None,
        completeness_score=None
    )
