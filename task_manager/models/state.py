"""
State module - Global agent state definition for LangGraph
"""

from typing import TypedDict, Annotated, List, Optional, Any, Dict, Required, NotRequired
import operator
from datetime import datetime
from .task import Task


# ============================================================================
# CUSTOM REDUCERS FOR DEDUPLICATION
# ============================================================================

def deduplicate_list_reducer(existing: List[str], new: List[str]) -> List[str]:
    """
    Custom reducer for LangGraph that prevents duplicate entries.
    
    LangGraph calls reducers multiple times during checkpointing and state merging,
    which causes exponential duplication with operator.add. This reducer ensures
    each item appears only once by converting to set and back.
    
    Args:
        existing: Current list of items
        new: New items to add
        
    Returns:
        Combined list with duplicates removed, preserving order
    """
    # Combine lists and remove duplicates while preserving order
    seen = set()
    result = []
    
    for item in existing + new:
        if item not in seen:
            seen.add(item)
            result.append(item)
    
    return result


# ============================================================================
# BLACKBOARD PATTERN TYPES
# ============================================================================

class HistoryEntry(TypedDict):
    """
    An annotated history of a completed step and its outcome.
    
    Attributes:
        timestamp: When the step was completed
        step_name: Name/ID of the completed step
        agent: Which sub-agent executed (pdf, excel, ocr, web_search, etc.)
        task_id: The task that was executed
        outcome: Result/findings from this step
        duration_seconds: How long the step took
        error: Any error that occurred (if applicable)
    """
    timestamp: str
    step_name: str
    agent: str
    task_id: str
    outcome: dict
    duration_seconds: float
    error: NotRequired[Optional[str]]


class BlackboardEntry(TypedDict):
    """
    A structured finding stored on the blackboard by any agent.
    
    Supports:
    - Nested entries for multi-level hierarchical analysis
    - File pointers for cross-agent workflow chaining
    - Chain execution metadata for agent-to-agent handoffs
    
    Attributes:
        entry_type: Category of finding (web_evidence, data_point, table, etc.)
        source_agent: Which agent posted this (pdf, excel, ocr, web_search)
        source_task_id: Which task produced this finding
        parent_task_id: Parent task ID (for nested entries in hierarchies)
        content: The actual finding data
        timestamp: When it was posted
        relevant_to: List of task IDs that might benefit from this finding
        depth_level: Hierarchical depth where this was found (0=root level)
        file_pointers: NEW - Paths/references to generated files for cross-agent use
        chain_next_agents: NEW - Agents that should execute next with this data
        source_file_path: NEW - Original file path if generated by agent
    """
    entry_type: str  # web_evidence, data_point, extracted_table, hypothesis, etc.
    source_agent: str
    source_task_id: str
    parent_task_id: NotRequired[Optional[str]]  # Parent task for nested hierarchies
    content: dict  # Flexible structure based on type
    timestamp: str
    relevant_to: List[str]  # Task IDs that might use this
    depth_level: NotRequired[int]  # Hierarchical depth (default 0)
    file_pointers: NotRequired[Dict[str, str]]  # NEW: {agent: file_path, ...} for handoffs
    chain_next_agents: NotRequired[List[str]]  # NEW: Agents to execute next
    source_file_path: NotRequired[Optional[str]]  # NEW: Original file that was processed


class PlanNode(TypedDict):
    """
    A node in the hierarchical task plan with graph-based dependency support.
    
    Supports:
    - Hierarchical decomposition (parent-child via parent_id)
    - Non-linear graph dependencies (task A depends on B AND C from different branches)
    - Context propagation from parent tasks
    - Multi-level analysis with dependency tracking
    
    Graph-of-Thought Feature:
    Unlike tree-based planning where a task depends only on its parent completing,
    this supports explicit cross-branch dependencies. For example:
    - Task A: "Analyze Data" (parent: root)
    - Task B: "Validate Results" (parent: root)  
    - Task C: "Generate Report" depends on BOTH A and B (dependency_task_ids=[A_id, B_id])
    This enables parallel execution and complex workflows.
    
    Attributes:
        task_id: Unique identifier
        parent_id: Parent task in hierarchy (for decomposition)
        depth: Nesting level (0=root)
        description: What this plan node accomplishes
        status: Current status (pending, ready, executing, completed, failed, blocked)
        priority: Execution priority (lower number = higher priority)
        dependency_task_ids: Task IDs that MUST complete before this task can start
                            (Empty list = no dependencies except parent)
        estimated_effort: Rough effort estimate (small, medium, large)
        context_summary: Key findings from parent task to guide execution
        child_task_ids: IDs of direct child tasks
    """
    task_id: str
    parent_id: NotRequired[Optional[str]]
    depth: int
    description: str
    status: str
    priority: int
    dependency_task_ids: NotRequired[List[str]]  # Cross-branch dependencies (Graph-of-Thought)
    estimated_effort: str
    context_summary: NotRequired[Optional[Dict[str, Any]]]  # Key findings from parent
    child_task_ids: NotRequired[List[str]]  # Direct children
    
    # Backward compatibility: keep 'dependencies' field but prefer 'dependency_task_ids'
    dependencies: NotRequired[List[str]]  # Deprecated: use dependency_task_ids


# ============================================================================
# ENHANCED AGENT STATE WITH BLACKBOARD PATTERN
# ============================================================================

class AgentState(TypedDict):
    """
    Enhanced agent state for sophisticated Master Planner architecture with deep hierarchies.
    
    Supports multi-level task decomposition with:
    - Context preservation from parent to child tasks
    - Depth limiting to prevent infinite recursion
    - Nested blackboard entries for organized multi-level analysis
    - Input context from user-provided files
    
    Workflow:
    1. Plan defines the hierarchical structure
    2. Blackboard is where agents post findings (with optional parent task tags)
    3. History tracks what was completed and outcomes
    4. next_step determines which node executes next (enables non-linear flow)
    5. Context flows from parent to child for informed execution
    6. Input context provides access to user-provided data files
    
    This allows agents to:
    - Share findings asynchronously via blackboard
    - Post findings to parent tasks for hierarchical organization
    - Discover and reuse findings from other agents
    - Build on previous work in non-linear order
    - Make decisions based on collective knowledge
    - Preserve context across multiple decomposition levels
    - Access user-provided input files as data sources
    """
    # ===== CORE METADATA =====
    objective: str  # Main goal/objective
    metadata: dict  # Additional context (e.g., district list, config, input_context)
    iteration_count: int  # Safety counter
    max_iterations: int  # Safety limit
    
    # ===== INPUT CONTEXT: USER-PROVIDED DATA =====
    input_context: NotRequired[Optional[Dict[str, Any]]]  # Scanned input folder context
    
    # ===== DEEP HIERARCHY CONTROL =====
    current_depth: NotRequired[int]  # Current execution depth (tracks position in hierarchy)
    depth_limit: int  # Maximum recursion depth (prevents infinite decomposition)
    parent_context: NotRequired[Optional[Dict[str, Any]]]  # Context from parent level
    
    # ===== MASTER PLANNER: HIERARCHICAL PLAN =====
    plan: Annotated[List[PlanNode], operator.add]  # Hierarchical task plan with context
    
    # ===== BLACKBOARD: SHARED FINDINGS & HYPOTHESES =====
    blackboard: Annotated[List[BlackboardEntry], operator.add]  # Agent findings (nested by parent)
    
    # ===== HISTORY: ANNOTATED EXECUTION LOG =====
    history: Annotated[List[HistoryEntry], operator.add]  # Completed steps and outcomes
    
    # ===== NEXT STEP: DYNAMIC ROUTING =====
    next_step: str  # Name of next node to invoke (enables non-linear flow)
    
    # ===== EXECUTION STATE (LEGACY COMPATIBILITY) =====
    tasks: List[Task]  # All tasks (replaceable for in-place updates)
    active_task_id: str  # Current task being processed
    completed_task_ids: Annotated[List[str], deduplicate_list_reducer]  # Completed tasks (deduplicated)
    failed_task_ids: Annotated[List[str], deduplicate_list_reducer]  # Failed tasks (deduplicated)
    results: dict  # Aggregated results by task_id
    
    # ===== HUMAN INTERACTION =====
    requires_human_review: bool  # Flag for human intervention
    human_feedback: str  # Optional feedback from human
